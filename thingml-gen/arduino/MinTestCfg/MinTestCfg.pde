
/***************************************************************************** 
 * File generated from ThingML (Do not edit this file) 
 *****************************************************************************/


/*****************************************************************************
 * Definition of simple types and enumerations
 *****************************************************************************/

// Definition of Enumeration  DigitalState
#define DIGITALSTATE_LOW 0
#define DIGITALSTATE_HIGH 1

// Definition of Enumeration  DigitalState
#define DIGITALSTATE_LOW 0
#define DIGITALSTATE_HIGH 1

/*****************************************************************************
 * Headers for type : test
 *****************************************************************************/

// Definition of the instance stuct:
struct test_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int test_TestChart_State;
// Variables for the properties of the instance
};

// Declaration of prototypes outgoing messages:
void test_TestChart_OnEntry(int state, struct test_Instance *_instance);
void test_handle_serial_serial_rx(struct test_Instance *_instance, uint8_t b);
void test_handle_serial_serial_opened(struct test_Instance *_instance);
// Declaration of callbacks for incomming messages:
void register_test_send_serial_serial_open_listener(void (*_listener)(struct test_Instance*, char *, int));
void register_test_send_serial_serial_close_listener(void (*_listener)(struct test_Instance*));
void register_test_send_serial_serial_tx_listener(void (*_listener)(struct test_Instance*, uint8_t));

// Definition of the states:
#define TEST_TESTCHART_STATE 0
#define TEST_TESTCHART_INIT_STATE 1
#define TEST_TESTCHART_PARLE_STATE 2

/*****************************************************************************
 * Implementation for type : test
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void test_TestChart_OnExit(int state, struct test_Instance *_instance);
void test_send_serial_serial_open(struct test_Instance *_instance, char * device, int baudrate);
void test_send_serial_serial_close(struct test_Instance *_instance);
void test_send_serial_serial_tx(struct test_Instance *_instance, uint8_t b);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void test_TestChart_OnEntry(int state, struct test_Instance *_instance) {
switch(state) {
case TEST_TESTCHART_STATE:
_instance->test_TestChart_State = TEST_TESTCHART_INIT_STATE;
test_TestChart_OnEntry(_instance->test_TestChart_State, _instance);
break;
case TEST_TESTCHART_INIT_STATE:
{
// PRINT: "[Test] Start\n"
test_send_serial_serial_open(_instance, "/dev/ttyATH0", 115200);
}
break;
case TEST_TESTCHART_PARLE_STATE:
{
// PRINT: "[Test] Parle\n"
test_send_serial_serial_tx(_instance, 0xff);
}
break;
default: break;
}
}

// On Exit Actions:
void test_TestChart_OnExit(int state, struct test_Instance *_instance) {
switch(state) {
case TEST_TESTCHART_STATE:
test_TestChart_OnExit(_instance->test_TestChart_State, _instance);
break;
case TEST_TESTCHART_INIT_STATE:
break;
case TEST_TESTCHART_PARLE_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void test_handle_serial_serial_rx(struct test_Instance *_instance, uint8_t b) {
uint8_t test_TestChart_State_event_consumed = 0;
if (_instance->test_TestChart_State == TEST_TESTCHART_PARLE_STATE) {
if (test_TestChart_State_event_consumed == 0 && 1) {
{
// PRINT: [Test] rx: \"b\"\n
}
test_TestChart_State_event_consumed = 1;
}
}
}
void test_handle_serial_serial_opened(struct test_Instance *_instance) {
uint8_t test_TestChart_State_event_consumed = 0;
if (_instance->test_TestChart_State == TEST_TESTCHART_INIT_STATE) {
if (test_TestChart_State_event_consumed == 0 && 1) {
test_TestChart_OnExit(TEST_TESTCHART_INIT_STATE, _instance);
_instance->test_TestChart_State = TEST_TESTCHART_PARLE_STATE;
test_TestChart_OnEntry(TEST_TESTCHART_PARLE_STATE, _instance);
test_TestChart_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*test_send_serial_serial_open_listener)(struct test_Instance*, char *, int)= 0x0;
void register_test_send_serial_serial_open_listener(void (*_listener)(struct test_Instance*, char *, int)){
test_send_serial_serial_open_listener = _listener;
}
void test_send_serial_serial_open(struct test_Instance *_instance, char * device, int baudrate){
if (test_send_serial_serial_open_listener != 0x0) test_send_serial_serial_open_listener(_instance, device, baudrate);
}
void (*test_send_serial_serial_close_listener)(struct test_Instance*)= 0x0;
void register_test_send_serial_serial_close_listener(void (*_listener)(struct test_Instance*)){
test_send_serial_serial_close_listener = _listener;
}
void test_send_serial_serial_close(struct test_Instance *_instance){
if (test_send_serial_serial_close_listener != 0x0) test_send_serial_serial_close_listener(_instance);
}
void (*test_send_serial_serial_tx_listener)(struct test_Instance*, uint8_t)= 0x0;
void register_test_send_serial_serial_tx_listener(void (*_listener)(struct test_Instance*, uint8_t)){
test_send_serial_serial_tx_listener = _listener;
}
void test_send_serial_serial_tx(struct test_Instance *_instance, uint8_t b){
if (test_send_serial_serial_tx_listener != 0x0) test_send_serial_serial_tx_listener(_instance, b);
}

/*****************************************************************************
 * Headers for type : LinuxSerial
 *****************************************************************************/


// BEGIN: Code from the c_header annotation LinuxSerial

#include <string.h> // string function definitions
#include <fcntl.h> // File control definitions
#include <errno.h> // Error number definitions
#include <termios.h> // POSIX terminal control definitions
#include <time.h>   // time calls

#define TIMEOUT 10 // timeout waiting for messages from the serial device
#define INPUT_BUFFER_SIZE 128 // for possible future optimizations
// END: Code from the c_header annotation LinuxSerial

// Definition of the instance stuct:
struct LinuxSerial_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int LinuxSerial_LinuxSerialImpl_State;
// Variables for the properties of the instance
int16_t LinuxSerial_LinuxSerialImpl_serial_device__var;
};

// Declaration of prototypes outgoing messages:
void LinuxSerial_LinuxSerialImpl_OnEntry(int state, struct LinuxSerial_Instance *_instance);
void LinuxSerial_handle_serial_serial_open(struct LinuxSerial_Instance *_instance, char * device, int baudrate);
void LinuxSerial_handle_serial_serial_tx(struct LinuxSerial_Instance *_instance, uint8_t b);
// Declaration of callbacks for incomming messages:
void register_LinuxSerial_send_serial_serial_rx_listener(void (*_listener)(struct LinuxSerial_Instance*, uint8_t));
void register_LinuxSerial_send_serial_serial_closed_listener(void (*_listener)(struct LinuxSerial_Instance*));
void register_LinuxSerial_send_serial_serial_opened_listener(void (*_listener)(struct LinuxSerial_Instance*));

// Definition of the states:
#define LINUXSERIAL_LINUXSERIALIMPL_STATE 0
#define LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE 1

/*****************************************************************************
 * Implementation for type : LinuxSerial
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void LinuxSerial_LinuxSerialImpl_OnExit(int state, struct LinuxSerial_Instance *_instance);
void LinuxSerial_send_serial_serial_rx(struct LinuxSerial_Instance *_instance, uint8_t b);
void LinuxSerial_send_serial_serial_closed(struct LinuxSerial_Instance *_instance);
void LinuxSerial_send_serial_serial_opened(struct LinuxSerial_Instance *_instance);
int16_t f_LinuxSerial_open_serial(struct LinuxSerial_Instance *_instance, char * device, int baudrate);
int16_t f_LinuxSerial_send_byte(struct LinuxSerial_Instance *_instance, int16_t device, uint8_t byte);
void f_LinuxSerial_start_receiver_process(struct LinuxSerial_Instance *_instance, int16_t device);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:
// Definition of function open_serial
int16_t f_LinuxSerial_open_serial(struct LinuxSerial_Instance *_instance, char * device, int baudrate) {
{
int result;
	
		printf("Opening ESUMS device at %s...\n", device);
		result = open(device, O_RDWR | O_NOCTTY | O_NDELAY);
	
		if (result < 0) {
			perror("Error opening Serial port");
		}
		else {
	
			//fcntl(result, F_SETFL, FNDELAY); // To make reading non-blocking ?
			fcntl(result, F_SETFL, 0); // To restore normal blocking read from the port
	
			printf("Configuring port %s...\n", device);
	
			struct termios port_settings;
	
			tcgetattr(result, &port_settings); // get current options
	
			cfsetispeed(&port_settings, B115200);    // set baud rates to 115200
			cfsetospeed(&port_settings, B115200);
	
			port_settings.c_cflag &= ~PARENB;	// Set 8N1, No Parity
			port_settings.c_cflag &= ~CSTOPB;
			port_settings.c_cflag &= ~CSIZE;
			port_settings.c_cflag |= CS8;
	
			port_settings.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG); // Raw input mode
	
			port_settings.c_oflag &= ~OPOST; // Raw output mode
	
			tcsetattr(result, TCSANOW, &port_settings);    // apply the settings to the port
		    sleep(1); // wait a bit
        }
return result;
}
}

// Definition of function send_byte
int16_t f_LinuxSerial_send_byte(struct LinuxSerial_Instance *_instance, int16_t device, uint8_t byte) {
{
int n;
		unsigned char data[1];
		data[0] = byte;
        
		n = write(device, data, 1);
		if (n < 0) {
			perror("Error writing to Serial device");
			return -1;
		}
		return 0;
}
}

// Fork a thread to execute the function f_LinuxSerial_start_receiver_process

// Struct for the parameters of the function  f_LinuxSerial_start_receiver_process
struct f_LinuxSerial_start_receiver_process_struct {
  struct LinuxSerial_Instance *_instance;
   int16_t device;

  pthread_mutex_t *lock;
  pthread_cond_t *cv;
};

// Definition of function start_receiver_process (executed in a separate thread)
void f_LinuxSerial_start_receiver_process_run(struct LinuxSerial_Instance *_instance, int16_t device)
{
  {
char buffer[INPUT_BUFFER_SIZE]; // Data read from the ESUSMS device

		int n; // used to store the results of select and read
		int i; // loop index
	
		while (1) {
	
			struct timeval timeout; // timeout waiting for incoming data
			timeout.tv_sec = TIMEOUT; 	// 10 second timeout
			timeout.tv_usec = 0;
	
			fd_set rdfs;		// The file descriptor to wait on
			FD_ZERO( &rdfs );
			FD_SET( device, &rdfs ); // set to the esusms fd
	
			n = select(device+1, &rdfs, NULL, NULL, &timeout); // Wait for timeout for something to be available to read
	
			if (n < 0) {
				perror("Error waiting for incoming data from Serial device");
				break;
			}
			else if (n == 0) { // timeout
				printf("Timeout waiting for incoming data from Serial device\n");
				break;
			}
			else { // there is something to read
	
				n = read(device, &buffer, INPUT_BUFFER_SIZE * sizeof(char));
	
				if (n<0) {
					perror("Error reading from Serial device");
					break;
				}
				else if (n==0) {
					printf("Nothing to read from Serial device\n"); // Should never happen unless there are too many transmission errors with wrong CRCs
					break;
				}
				else { // There are n incoming bytes in buffer
	
					char c;
					int size;
	
					for (i = 0; i<n; i++) {
						
LinuxSerial_send_serial_serial_rx(_instance, buffer[i]);

					}
				}
			}
		}
LinuxSerial_send_serial_serial_closed(_instance);
}

}


void f_LinuxSerial_start_receiver_process_proc(void * p)
{
  // Get parameters from the main thread
  struct f_LinuxSerial_start_receiver_process_struct params = *((struct f_LinuxSerial_start_receiver_process_struct *) p);
  
  // Unblock the main thread
  pthread_mutex_lock(params.lock);
  pthread_cond_signal(params.cv);
  pthread_mutex_unlock(params.lock);
  
  // Run the function
  //f_LinuxSerial_start_receiver_process_run(params._instance, params.esums_device);
  f_LinuxSerial_start_receiver_process_run(params._instance, params.device);
}

// Operation called by the runtime and forking a new thread
void f_LinuxSerial_start_receiver_process(struct LinuxSerial_Instance *_instance, int16_t device)
{
  // Store parameters
  struct f_LinuxSerial_start_receiver_process_struct params;
  pthread_mutex_t lock;
  pthread_cond_t cv;
  params.lock = &lock;
  params.cv = &cv;
  params._instance = _instance;
  params.device = device;

  pthread_mutex_init(params.lock, NULL);
  pthread_cond_init(params.cv, NULL);
  //Start the new thread
  pthread_mutex_lock(params.lock);
  pthread_t thread; 
  pthread_create( &thread, NULL, f_LinuxSerial_start_receiver_process_proc, (void*) &params);
  // Wait until it has started and read its parameters
  pthread_cond_wait(params.cv, params.lock);
  // Realease mutex
  pthread_mutex_unlock(params.lock);
}

// On Entry Actions:
void LinuxSerial_LinuxSerialImpl_OnEntry(int state, struct LinuxSerial_Instance *_instance) {
switch(state) {
case LINUXSERIAL_LINUXSERIALIMPL_STATE:
_instance->LinuxSerial_LinuxSerialImpl_State = LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE;
LinuxSerial_LinuxSerialImpl_OnEntry(_instance->LinuxSerial_LinuxSerialImpl_State, _instance);
break;
case LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE:
break;
default: break;
}
}

// On Exit Actions:
void LinuxSerial_LinuxSerialImpl_OnExit(int state, struct LinuxSerial_Instance *_instance) {
switch(state) {
case LINUXSERIAL_LINUXSERIALIMPL_STATE:
LinuxSerial_LinuxSerialImpl_OnExit(_instance->LinuxSerial_LinuxSerialImpl_State, _instance);
break;
case LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void LinuxSerial_handle_serial_serial_open(struct LinuxSerial_Instance *_instance, char * device, int baudrate) {
uint8_t LinuxSerial_LinuxSerialImpl_State_event_consumed = 0;
if (_instance->LinuxSerial_LinuxSerialImpl_State == LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE) {
if (LinuxSerial_LinuxSerialImpl_State_event_consumed == 0 && 1) {
{
_instance->LinuxSerial_LinuxSerialImpl_serial_device__var = f_LinuxSerial_open_serial(_instance, device, baudrate);
if(_instance->LinuxSerial_LinuxSerialImpl_serial_device__var >  -1) {
f_LinuxSerial_start_receiver_process(_instance, _instance->LinuxSerial_LinuxSerialImpl_serial_device__var);
LinuxSerial_send_serial_serial_opened(_instance);
}
}
LinuxSerial_LinuxSerialImpl_State_event_consumed = 1;
}
}
}
void LinuxSerial_handle_serial_serial_tx(struct LinuxSerial_Instance *_instance, uint8_t b) {
uint8_t LinuxSerial_LinuxSerialImpl_State_event_consumed = 0;
if (_instance->LinuxSerial_LinuxSerialImpl_State == LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE) {
if (LinuxSerial_LinuxSerialImpl_State_event_consumed == 0 && 1) {
{
// PRINT: "writing"
f_LinuxSerial_send_byte(_instance, _instance->LinuxSerial_LinuxSerialImpl_serial_device__var, b);
}
LinuxSerial_LinuxSerialImpl_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*LinuxSerial_send_serial_serial_rx_listener)(struct LinuxSerial_Instance*, uint8_t)= 0x0;
void register_LinuxSerial_send_serial_serial_rx_listener(void (*_listener)(struct LinuxSerial_Instance*, uint8_t)){
LinuxSerial_send_serial_serial_rx_listener = _listener;
}
void LinuxSerial_send_serial_serial_rx(struct LinuxSerial_Instance *_instance, uint8_t b){
if (LinuxSerial_send_serial_serial_rx_listener != 0x0) LinuxSerial_send_serial_serial_rx_listener(_instance, b);
}
void (*LinuxSerial_send_serial_serial_closed_listener)(struct LinuxSerial_Instance*)= 0x0;
void register_LinuxSerial_send_serial_serial_closed_listener(void (*_listener)(struct LinuxSerial_Instance*)){
LinuxSerial_send_serial_serial_closed_listener = _listener;
}
void LinuxSerial_send_serial_serial_closed(struct LinuxSerial_Instance *_instance){
if (LinuxSerial_send_serial_serial_closed_listener != 0x0) LinuxSerial_send_serial_serial_closed_listener(_instance);
}
void (*LinuxSerial_send_serial_serial_opened_listener)(struct LinuxSerial_Instance*)= 0x0;
void register_LinuxSerial_send_serial_serial_opened_listener(void (*_listener)(struct LinuxSerial_Instance*)){
LinuxSerial_send_serial_serial_opened_listener = _listener;
}
void LinuxSerial_send_serial_serial_opened(struct LinuxSerial_Instance *_instance){
if (LinuxSerial_send_serial_serial_opened_listener != 0x0) LinuxSerial_send_serial_serial_opened_listener(_instance);
}


/*****************************************************************************
 * Definitions for configuration : MinTestCfg
 *****************************************************************************/

#define MAX_INSTANCES 32
#define FIFO_SIZE 256

/*********************************
 * Instance IDs and lookup
 *********************************/

void * instances[MAX_INSTANCES];
uint16_t instances_count = 0;

void * instance_by_id(uint16_t id) {
  return instances[id];
}

uint16_t add_instance(void * instance_struct) {
  instances[instances_count] = instance_struct;
  return instances_count++;
}

/******************************************
 * Simple byte FIFO implementation
 ******************************************/

byte fifo[FIFO_SIZE];
int fifo_head = 0;
int fifo_tail = 0;

// Returns the number of byte currently in the fifo
int fifo_byte_length() {
  if (fifo_tail >= fifo_head)
    return fifo_tail - fifo_head;
  return fifo_tail + FIFO_SIZE - fifo_head;
}

// Returns the number of bytes currently available in the fifo
int fifo_byte_available() {
  return FIFO_SIZE - 1 - fifo_byte_length();
}

// Returns true if the fifo is empty
int fifo_empty() {
  return fifo_head == fifo_tail;
}

// Return true if the fifo is full
int fifo_full() {
  return fifo_head == ((fifo_tail + 1) % FIFO_SIZE);
}

// Enqueue 1 byte in the fifo if there is space
// returns 1 for sucess and 0 if the fifo was full
int fifo_enqueue(byte b) {
  int new_tail = (fifo_tail + 1) % FIFO_SIZE;
  if (new_tail == fifo_head) return 0; // the fifo is full
  fifo[fifo_tail] = b;
  fifo_tail = new_tail;
  return 1;
}

// Enqueue 1 byte in the fifo without checking for available space
// The caller should have checked that there is enough space
int _fifo_enqueue(byte b) {
  fifo[fifo_tail] = b;
  fifo_tail = (fifo_tail + 1) % FIFO_SIZE;
}

// Dequeue 1 byte in the fifo.
// The caller should check that the fifo is not empty
byte fifo_dequeue() {
  if (!fifo_empty()) {
    byte result = fifo[fifo_head];
    fifo_head = (fifo_head + 1) % FIFO_SIZE;
    return result;
  }
  return 0;
}

/*
void _fifo_enqueue_ptr(void * ptr) {
  int i;
  ptr_union_t proxy;
  proxy.pointer = ptr;
  for (i = 0; i<PTR_MAX_SIZE; i++) _fifo_enqueue(proxy.buffer[i]);
}

void * _fifo_dequeue_ptr() {
  int i;
  ptr_union_t proxy;
  for (i = 0; i<PTR_MAX_SIZE; i++) proxy.buffer[i] = _fifo_dequeue();
  return proxy.pointer;
}
*/
//Declaration of instance variables
struct LinuxSerial_Instance MinTestCfg_sp_var;
struct test_Instance MinTestCfg_t_var;


// Dispatch for messages LinuxSerial::serial::serial_rx
void dispatch_LinuxSerial_send_serial_serial_rx(struct LinuxSerial_Instance *_instance, uint8_t b){
if (_instance == &MinTestCfg_sp_var) {
test_handle_serial_serial_rx(&MinTestCfg_t_var, b);
}
}
// Dispatch for messages LinuxSerial::serial::serial_closed
void dispatch_LinuxSerial_send_serial_serial_closed(struct LinuxSerial_Instance *_instance){
if (_instance == &MinTestCfg_sp_var) {
}
}
// Dispatch for messages LinuxSerial::serial::serial_opened
void dispatch_LinuxSerial_send_serial_serial_opened(struct LinuxSerial_Instance *_instance){
if (_instance == &MinTestCfg_sp_var) {
test_handle_serial_serial_opened(&MinTestCfg_t_var);
}
}
// Dispatch for messages test::serial::serial_open
void dispatch_test_send_serial_serial_open(struct test_Instance *_instance, char * device, int baudrate){
if (_instance == &MinTestCfg_t_var) {
LinuxSerial_handle_serial_serial_open(&MinTestCfg_sp_var, device, baudrate);
}
}
// Dispatch for messages test::serial::serial_close
void dispatch_test_send_serial_serial_close(struct test_Instance *_instance){
if (_instance == &MinTestCfg_t_var) {
}
}
// Dispatch for messages test::serial::serial_tx
void dispatch_test_send_serial_serial_tx(struct test_Instance *_instance, uint8_t b){
if (_instance == &MinTestCfg_t_var) {
LinuxSerial_handle_serial_serial_tx(&MinTestCfg_sp_var, b);
}
}

void processMessageQueue() {
if (fifo_empty()) return; // return if there is nothing to do

byte mbuf[2];
uint8_t mbufi = 0;

// Read the code of the next port/message in the queue
uint16_t code = fifo_dequeue() << 8;

code += fifo_dequeue();

// Switch to call the appropriate handler
switch(code) {
}
}

void initialize_configuration_MinTestCfg() {
// Initialize connectors
register_test_send_serial_serial_open_listener(dispatch_test_send_serial_serial_open);
register_test_send_serial_serial_close_listener(dispatch_test_send_serial_serial_close);
register_test_send_serial_serial_tx_listener(dispatch_test_send_serial_serial_tx);
register_LinuxSerial_send_serial_serial_rx_listener(dispatch_LinuxSerial_send_serial_serial_rx);
register_LinuxSerial_send_serial_serial_closed_listener(dispatch_LinuxSerial_send_serial_serial_closed);
register_LinuxSerial_send_serial_serial_opened_listener(dispatch_LinuxSerial_send_serial_serial_opened);

// Init the ID, state variables and properties for instance MinTestCfg_sp
MinTestCfg_sp_var.id = add_instance( (void*) &MinTestCfg_sp_var);
MinTestCfg_sp_var.LinuxSerial_LinuxSerialImpl_State = LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE;

// Init the ID, state variables and properties for instance MinTestCfg_t
MinTestCfg_t_var.id = add_instance( (void*) &MinTestCfg_t_var);
MinTestCfg_t_var.test_TestChart_State = TEST_TESTCHART_INIT_STATE;

LinuxSerial_LinuxSerialImpl_OnEntry(LINUXSERIAL_LINUXSERIALIMPL_STATE, &MinTestCfg_sp_var);
test_TestChart_OnEntry(TEST_TESTCHART_STATE, &MinTestCfg_t_var);
}

/*****************************************************************************
 * Main for configuration : MinTestCfg
 *****************************************************************************/

void setup() {
initialize_configuration_MinTestCfg();

}

void loop() {

processMessageQueue();
}