
/***************************************************************************** 
 * File generated from ThingML (Do not edit this file) 
 *****************************************************************************/


/*****************************************************************************
 * Definition of simple types and enumerations
 *****************************************************************************/

// Definition of Enumeration  DigitalState
#define DIGITALSTATE_LOW 0
#define DIGITALSTATE_HIGH 1

// Definition of Enumeration  DigitalState
#define DIGITALSTATE_LOW 0
#define DIGITALSTATE_HIGH 1

/*****************************************************************************
 * Headers for type : Bridge
 *****************************************************************************/

// Definition of the instance stuct:
struct Bridge_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int Bridge_BridgeChart_State;
int Bridge_BridgeChart_Active_State;
// Variables for the properties of the instance
uint8_t Bridge_START_BYTE__var;
uint8_t Bridge_STOP_BYTE__var;
uint8_t Bridge_ESCAPE_BYTE__var;
uint8_t Bridge_Buffer__var[32];
uint8_t Bridge_MsgSize__var;
};

// Declaration of prototypes outgoing messages:
void Bridge_BridgeChart_OnEntry(int state, struct Bridge_Instance *_instance);
void Bridge_handle_Serial1_setDigitalHigh(struct Bridge_Instance *_instance, uint8_t pin);
void Bridge_handle_Serial1_readAnalog(struct Bridge_Instance *_instance, uint8_t pin);
void Bridge_handle_Serial1_readDigital(struct Bridge_Instance *_instance, uint8_t pin);
void Bridge_handle_Serial1_setOutput(struct Bridge_Instance *_instance, uint8_t pin);
void Bridge_handle_Serial1_setInput(struct Bridge_Instance *_instance, uint8_t pin);
void Bridge_handle_Serial1_timer_start(struct Bridge_Instance *_instance, uint8_t id, int16_t time);
void Bridge_handle_Serial1_timer_cancel(struct Bridge_Instance *_instance, uint8_t id);
void Bridge_handle_Serial1_setDigitalLow(struct Bridge_Instance *_instance, uint8_t pin);
void Bridge_handle_serial_serial_opened(struct Bridge_Instance *_instance);
void Bridge_handle_serial_serial_rx(struct Bridge_Instance *_instance, uint8_t b);
// Declaration of callbacks for incomming messages:
void register_Bridge_send_Serial1_readDigitalResponse_listener(void (*_listener)(struct Bridge_Instance*, uint8_t, uint8_t));
void register_Bridge_send_Serial1_readAnalogResponse_listener(void (*_listener)(struct Bridge_Instance*, uint8_t, int));
void register_Bridge_send_Serial1_timeout_listener(void (*_listener)(struct Bridge_Instance*, uint8_t));
void register_Bridge_send_Serial1_CPUBridgeReady_listener(void (*_listener)(struct Bridge_Instance*));
void register_Bridge_send_serial_serial_open_listener(void (*_listener)(struct Bridge_Instance*, char *, int));
void register_Bridge_send_serial_serial_close_listener(void (*_listener)(struct Bridge_Instance*));
void register_Bridge_send_serial_serial_tx_listener(void (*_listener)(struct Bridge_Instance*, uint8_t));

// Definition of the states:
#define BRIDGE_BRIDGECHART_STATE 0
#define BRIDGE_BRIDGECHART_INIT_STATE 1
#define BRIDGE_BRIDGECHART_ACTIVE_STATE 2
#define BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE 3
#define BRIDGE_BRIDGECHART_ACTIVE_READING_STATE 4
#define BRIDGE_BRIDGECHART_ACTIVE_ESCAPING_STATE 5
#define BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE 6

/*****************************************************************************
 * Implementation for type : Bridge
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void Bridge_BridgeChart_OnExit(int state, struct Bridge_Instance *_instance);
void Bridge_send_Serial1_readDigitalResponse(struct Bridge_Instance *_instance, uint8_t pin, uint8_t DigitalState);
void Bridge_send_Serial1_readAnalogResponse(struct Bridge_Instance *_instance, uint8_t pin, int res);
void Bridge_send_Serial1_timeout(struct Bridge_Instance *_instance, uint8_t id);
void Bridge_send_Serial1_CPUBridgeReady(struct Bridge_Instance *_instance);
void Bridge_send_serial_serial_open(struct Bridge_Instance *_instance, char * device, int baudrate);
void Bridge_send_serial_serial_close(struct Bridge_Instance *_instance);
void Bridge_send_serial_serial_tx(struct Bridge_Instance *_instance, uint8_t b);
void f_Bridge_SerialSend(struct Bridge_Instance *_instance, uint8_t b);
void f_Bridge_SerialStart(struct Bridge_Instance *_instance);
void f_Bridge_SerialStop(struct Bridge_Instance *_instance);
void f_Bridge_parse(struct Bridge_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:
// Definition of function SerialSend
void f_Bridge_SerialSend(struct Bridge_Instance *_instance, uint8_t b) {
{
if((b == _instance->Bridge_START_BYTE__var) || (b == _instance->Bridge_STOP_BYTE__var) || (b == _instance->Bridge_ESCAPE_BYTE__var)) {
Bridge_send_serial_serial_tx(_instance, _instance->Bridge_ESCAPE_BYTE__var);
}
Bridge_send_serial_serial_tx(_instance, b);
}
}

// Definition of function SerialStart
void f_Bridge_SerialStart(struct Bridge_Instance *_instance) {
{
Bridge_send_serial_serial_tx(_instance, _instance->Bridge_START_BYTE__var);
}
}

// Definition of function SerialStop
void f_Bridge_SerialStop(struct Bridge_Instance *_instance) {
{
Bridge_send_serial_serial_tx(_instance, _instance->Bridge_STOP_BYTE__var);
}
}

// Definition of function parse
void f_Bridge_parse(struct Bridge_Instance *_instance) {
{
uint16_t msgID = 256 * _instance->Bridge_Buffer__var[0] + _instance->Bridge_Buffer__var[1];
		switch(msgID){
			case 2://readDigitalResponse
				if(_instance->Bridge_Buffer__var[5] == 0) {
					
Bridge_send_Serial1_readDigitalResponse(_instance, _instance->Bridge_Buffer__var[4], DIGITALSTATE_LOW);

				} else {
					
Bridge_send_Serial1_readDigitalResponse(_instance, _instance->Bridge_Buffer__var[4], DIGITALSTATE_HIGH);

				}
			break;
			
			case 9://readAnalogResponse
				
Bridge_send_Serial1_readAnalogResponse(_instance, _instance->Bridge_Buffer__var[4], _instance->Bridge_Buffer__var[5] * 256 + _instance->Bridge_Buffer__var[6]);

			break;
			
			case 8://timeout
				
Bridge_send_Serial1_timeout(_instance, _instance->Bridge_Buffer__var[4]);

			break;
		}
}
}


// On Entry Actions:
void Bridge_BridgeChart_OnEntry(int state, struct Bridge_Instance *_instance) {
switch(state) {
case BRIDGE_BRIDGECHART_STATE:
_instance->Bridge_BridgeChart_State = BRIDGE_BRIDGECHART_INIT_STATE;
Bridge_BridgeChart_OnEntry(_instance->Bridge_BridgeChart_State, _instance);
break;
case BRIDGE_BRIDGECHART_INIT_STATE:
{
Bridge_send_serial_serial_open(_instance, "/dev/ttyATH0", 115200);
}
break;
case BRIDGE_BRIDGECHART_ACTIVE_STATE:
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE;
Bridge_BridgeChart_OnEntry(_instance->Bridge_BridgeChart_Active_State, _instance);
break;
case BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE:
break;
case BRIDGE_BRIDGECHART_ACTIVE_READING_STATE:
break;
case BRIDGE_BRIDGECHART_ACTIVE_ESCAPING_STATE:
break;
case BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE:
break;
default: break;
}
}

// On Exit Actions:
void Bridge_BridgeChart_OnExit(int state, struct Bridge_Instance *_instance) {
switch(state) {
case BRIDGE_BRIDGECHART_STATE:
Bridge_BridgeChart_OnExit(_instance->Bridge_BridgeChart_State, _instance);
break;
case BRIDGE_BRIDGECHART_INIT_STATE:
break;
case BRIDGE_BRIDGECHART_ACTIVE_STATE:
Bridge_BridgeChart_OnExit(_instance->Bridge_BridgeChart_Active_State, _instance);
break;
case BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE:
break;
case BRIDGE_BRIDGECHART_ACTIVE_READING_STATE:
break;
case BRIDGE_BRIDGECHART_ACTIVE_ESCAPING_STATE:
break;
case BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void Bridge_handle_Serial1_setDigitalHigh(struct Bridge_Instance *_instance, uint8_t pin) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
f_Bridge_SerialStart(_instance);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 11);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 1);
f_Bridge_SerialSend(_instance, pin);
f_Bridge_SerialStop(_instance);
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_Serial1_readAnalog(struct Bridge_Instance *_instance, uint8_t pin) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
f_Bridge_SerialStart(_instance);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 10);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 1);
f_Bridge_SerialSend(_instance, pin);
f_Bridge_SerialStop(_instance);
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_Serial1_readDigital(struct Bridge_Instance *_instance, uint8_t pin) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
f_Bridge_SerialStart(_instance);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 14);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 1);
f_Bridge_SerialSend(_instance, pin);
f_Bridge_SerialStop(_instance);
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_Serial1_setOutput(struct Bridge_Instance *_instance, uint8_t pin) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
f_Bridge_SerialStart(_instance);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 12);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 1);
f_Bridge_SerialSend(_instance, pin);
f_Bridge_SerialStop(_instance);
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_Serial1_setInput(struct Bridge_Instance *_instance, uint8_t pin) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
f_Bridge_SerialStart(_instance);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 15);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 1);
f_Bridge_SerialSend(_instance, pin);
f_Bridge_SerialStop(_instance);
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_Serial1_timer_start(struct Bridge_Instance *_instance, uint8_t id, int16_t time) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
f_Bridge_SerialStart(_instance);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 16);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 1);
f_Bridge_SerialSend(_instance, id);
f_Bridge_SerialSend(_instance, (time>>8) & 0xFF);
f_Bridge_SerialSend(_instance, time & 0xFF);
f_Bridge_SerialStop(_instance);
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_Serial1_timer_cancel(struct Bridge_Instance *_instance, uint8_t id) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
f_Bridge_SerialStart(_instance);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 17);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 1);
f_Bridge_SerialSend(_instance, id);
f_Bridge_SerialStop(_instance);
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_Serial1_setDigitalLow(struct Bridge_Instance *_instance, uint8_t pin) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
f_Bridge_SerialStart(_instance);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 13);
f_Bridge_SerialSend(_instance, 0);
f_Bridge_SerialSend(_instance, 1);
f_Bridge_SerialSend(_instance, pin);
f_Bridge_SerialStop(_instance);
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_serial_serial_opened(struct Bridge_Instance *_instance) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_INIT_STATE) {
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_INIT_STATE, _instance);
_instance->Bridge_BridgeChart_State = BRIDGE_BRIDGECHART_ACTIVE_STATE;
{
Bridge_send_Serial1_CPUBridgeReady(_instance);
}
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_STATE, _instance);
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_serial_serial_rx(struct Bridge_Instance *_instance, uint8_t b) {
uint8_t Bridge_BridgeChart_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
uint8_t Bridge_BridgeChart_Active_State_event_consumed = 0;
if (_instance->Bridge_BridgeChart_Active_State == BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE) {
if (Bridge_BridgeChart_Active_State_event_consumed == 0 && b == _instance->Bridge_START_BYTE__var) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE, _instance);
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_READING_STATE;
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_READING_STATE, _instance);
Bridge_BridgeChart_Active_State_event_consumed = 1;
}
}
else if (_instance->Bridge_BridgeChart_Active_State == BRIDGE_BRIDGECHART_ACTIVE_READING_STATE) {
if (Bridge_BridgeChart_Active_State_event_consumed == 0 && _instance->Bridge_MsgSize__var > 31) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_ACTIVE_READING_STATE, _instance);
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE;
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE, _instance);
Bridge_BridgeChart_Active_State_event_consumed = 1;
}
else if (Bridge_BridgeChart_Active_State_event_consumed == 0 && b == _instance->Bridge_ESCAPE_BYTE__var) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_ACTIVE_READING_STATE, _instance);
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_ESCAPING_STATE;
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_ESCAPING_STATE, _instance);
Bridge_BridgeChart_Active_State_event_consumed = 1;
}
else if (Bridge_BridgeChart_Active_State_event_consumed == 0 && b == _instance->Bridge_STOP_BYTE__var) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_ACTIVE_READING_STATE, _instance);
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE;
{
f_Bridge_parse(_instance);
_instance->Bridge_MsgSize__var = 0;
}
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE, _instance);
Bridge_BridgeChart_Active_State_event_consumed = 1;
}
else if (Bridge_BridgeChart_Active_State_event_consumed == 0 && 1) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_ACTIVE_READING_STATE, _instance);
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_READING_STATE;
{
_instance->Bridge_Buffer__var[_instance->Bridge_MsgSize__var] = b;
_instance->Bridge_MsgSize__var = _instance->Bridge_MsgSize__var + 1;
}
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_READING_STATE, _instance);
Bridge_BridgeChart_Active_State_event_consumed = 1;
}
}
else if (_instance->Bridge_BridgeChart_Active_State == BRIDGE_BRIDGECHART_ACTIVE_ESCAPING_STATE) {
if (Bridge_BridgeChart_Active_State_event_consumed == 0 && _instance->Bridge_MsgSize__var > 31) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_ACTIVE_ESCAPING_STATE, _instance);
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE;
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE, _instance);
Bridge_BridgeChart_Active_State_event_consumed = 1;
}
else if (Bridge_BridgeChart_Active_State_event_consumed == 0 && 1) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_ACTIVE_ESCAPING_STATE, _instance);
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_READING_STATE;
{
_instance->Bridge_Buffer__var[_instance->Bridge_MsgSize__var] = b;
_instance->Bridge_MsgSize__var = _instance->Bridge_MsgSize__var + 1;
}
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_READING_STATE, _instance);
Bridge_BridgeChart_Active_State_event_consumed = 1;
}
}
Bridge_BridgeChart_State_event_consumed = 0 | Bridge_BridgeChart_Active_State_event_consumed ;
if (Bridge_BridgeChart_State_event_consumed == 0 && 1) {
{
// PRINT: "[Bridge] received: " + b
// PRINT: "\n"
}
Bridge_BridgeChart_State_event_consumed = 1;
}
}
}
void Bridge_handle_empty_event(struct Bridge_Instance *_instance) {
if (_instance->Bridge_BridgeChart_State == BRIDGE_BRIDGECHART_ACTIVE_STATE) {
if (_instance->Bridge_BridgeChart_Active_State == BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE) {
if (1) {
Bridge_BridgeChart_OnExit(BRIDGE_BRIDGECHART_ACTIVE_ERROR_STATE, _instance);
_instance->Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE;
{
_instance->Bridge_MsgSize__var = 0;
}
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE, _instance);
}
}
}
}

// Observers for outgoing messages:
void (*Bridge_send_Serial1_readDigitalResponse_listener)(struct Bridge_Instance*, uint8_t, uint8_t)= 0x0;
void register_Bridge_send_Serial1_readDigitalResponse_listener(void (*_listener)(struct Bridge_Instance*, uint8_t, uint8_t)){
Bridge_send_Serial1_readDigitalResponse_listener = _listener;
}
void Bridge_send_Serial1_readDigitalResponse(struct Bridge_Instance *_instance, uint8_t pin, uint8_t DigitalState){
if (Bridge_send_Serial1_readDigitalResponse_listener != 0x0) Bridge_send_Serial1_readDigitalResponse_listener(_instance, pin, DigitalState);
}
void (*Bridge_send_Serial1_readAnalogResponse_listener)(struct Bridge_Instance*, uint8_t, int)= 0x0;
void register_Bridge_send_Serial1_readAnalogResponse_listener(void (*_listener)(struct Bridge_Instance*, uint8_t, int)){
Bridge_send_Serial1_readAnalogResponse_listener = _listener;
}
void Bridge_send_Serial1_readAnalogResponse(struct Bridge_Instance *_instance, uint8_t pin, int res){
if (Bridge_send_Serial1_readAnalogResponse_listener != 0x0) Bridge_send_Serial1_readAnalogResponse_listener(_instance, pin, res);
}
void (*Bridge_send_Serial1_timeout_listener)(struct Bridge_Instance*, uint8_t)= 0x0;
void register_Bridge_send_Serial1_timeout_listener(void (*_listener)(struct Bridge_Instance*, uint8_t)){
Bridge_send_Serial1_timeout_listener = _listener;
}
void Bridge_send_Serial1_timeout(struct Bridge_Instance *_instance, uint8_t id){
if (Bridge_send_Serial1_timeout_listener != 0x0) Bridge_send_Serial1_timeout_listener(_instance, id);
}
void (*Bridge_send_Serial1_CPUBridgeReady_listener)(struct Bridge_Instance*)= 0x0;
void register_Bridge_send_Serial1_CPUBridgeReady_listener(void (*_listener)(struct Bridge_Instance*)){
Bridge_send_Serial1_CPUBridgeReady_listener = _listener;
}
void Bridge_send_Serial1_CPUBridgeReady(struct Bridge_Instance *_instance){
if (Bridge_send_Serial1_CPUBridgeReady_listener != 0x0) Bridge_send_Serial1_CPUBridgeReady_listener(_instance);
}
void (*Bridge_send_serial_serial_open_listener)(struct Bridge_Instance*, char *, int)= 0x0;
void register_Bridge_send_serial_serial_open_listener(void (*_listener)(struct Bridge_Instance*, char *, int)){
Bridge_send_serial_serial_open_listener = _listener;
}
void Bridge_send_serial_serial_open(struct Bridge_Instance *_instance, char * device, int baudrate){
if (Bridge_send_serial_serial_open_listener != 0x0) Bridge_send_serial_serial_open_listener(_instance, device, baudrate);
}
void (*Bridge_send_serial_serial_close_listener)(struct Bridge_Instance*)= 0x0;
void register_Bridge_send_serial_serial_close_listener(void (*_listener)(struct Bridge_Instance*)){
Bridge_send_serial_serial_close_listener = _listener;
}
void Bridge_send_serial_serial_close(struct Bridge_Instance *_instance){
if (Bridge_send_serial_serial_close_listener != 0x0) Bridge_send_serial_serial_close_listener(_instance);
}
void (*Bridge_send_serial_serial_tx_listener)(struct Bridge_Instance*, uint8_t)= 0x0;
void register_Bridge_send_serial_serial_tx_listener(void (*_listener)(struct Bridge_Instance*, uint8_t)){
Bridge_send_serial_serial_tx_listener = _listener;
}
void Bridge_send_serial_serial_tx(struct Bridge_Instance *_instance, uint8_t b){
if (Bridge_send_serial_serial_tx_listener != 0x0) Bridge_send_serial_serial_tx_listener(_instance, b);
}

/*****************************************************************************
 * Headers for type : LinuxSerial
 *****************************************************************************/


// BEGIN: Code from the c_header annotation LinuxSerial

#include <string.h> // string function definitions
#include <fcntl.h> // File control definitions
#include <errno.h> // Error number definitions
#include <termios.h> // POSIX terminal control definitions
#include <time.h>   // time calls

#define TIMEOUT 10 // timeout waiting for messages from the serial device
#define INPUT_BUFFER_SIZE 128 // for possible future optimizations
// END: Code from the c_header annotation LinuxSerial

// Definition of the instance stuct:
struct LinuxSerial_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int LinuxSerial_LinuxSerialImpl_State;
// Variables for the properties of the instance
int16_t LinuxSerial_LinuxSerialImpl_serial_device__var;
};

// Declaration of prototypes outgoing messages:
void LinuxSerial_LinuxSerialImpl_OnEntry(int state, struct LinuxSerial_Instance *_instance);
void LinuxSerial_handle_serial_serial_open(struct LinuxSerial_Instance *_instance, char * device, int baudrate);
void LinuxSerial_handle_serial_serial_tx(struct LinuxSerial_Instance *_instance, uint8_t b);
// Declaration of callbacks for incomming messages:
void register_LinuxSerial_send_serial_serial_rx_listener(void (*_listener)(struct LinuxSerial_Instance*, uint8_t));
void register_LinuxSerial_send_serial_serial_closed_listener(void (*_listener)(struct LinuxSerial_Instance*));
void register_LinuxSerial_send_serial_serial_opened_listener(void (*_listener)(struct LinuxSerial_Instance*));

// Definition of the states:
#define LINUXSERIAL_LINUXSERIALIMPL_STATE 0
#define LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE 1

/*****************************************************************************
 * Implementation for type : LinuxSerial
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void LinuxSerial_LinuxSerialImpl_OnExit(int state, struct LinuxSerial_Instance *_instance);
void LinuxSerial_send_serial_serial_rx(struct LinuxSerial_Instance *_instance, uint8_t b);
void LinuxSerial_send_serial_serial_closed(struct LinuxSerial_Instance *_instance);
void LinuxSerial_send_serial_serial_opened(struct LinuxSerial_Instance *_instance);
int16_t f_LinuxSerial_open_serial(struct LinuxSerial_Instance *_instance, char * device, int baudrate);
int16_t f_LinuxSerial_send_byte(struct LinuxSerial_Instance *_instance, int16_t device, uint8_t byte);
void f_LinuxSerial_start_receiver_process(struct LinuxSerial_Instance *_instance, int16_t device);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:
// Definition of function open_serial
int16_t f_LinuxSerial_open_serial(struct LinuxSerial_Instance *_instance, char * device, int baudrate) {
{
int result;
	
		printf("Opening ESUMS device at %s...\n", device);
		result = open(device, O_RDWR | O_NOCTTY | O_NDELAY);
	
		if (result < 0) {
			perror("Error opening Serial port");
		}
		else {
	
			//fcntl(result, F_SETFL, FNDELAY); // To make reading non-blocking ?
			fcntl(result, F_SETFL, 0); // To restore normal blocking read from the port
	
			printf("Configuring port %s...\n", device);
	
			struct termios port_settings;
	
			tcgetattr(result, &port_settings); // get current options
	
			cfsetispeed(&port_settings, B115200);    // set baud rates to 115200
			cfsetospeed(&port_settings, B115200);
	
			port_settings.c_cflag &= ~PARENB;	// Set 8N1, No Parity
			port_settings.c_cflag &= ~CSTOPB;
			port_settings.c_cflag &= ~CSIZE;
			port_settings.c_cflag |= CS8;
	
			port_settings.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG); // Raw input mode
	
			port_settings.c_oflag &= ~OPOST; // Raw output mode
	
			tcsetattr(result, TCSANOW, &port_settings);    // apply the settings to the port
		    sleep(1); // wait a bit
        }
return result;
}
}

// Definition of function send_byte
int16_t f_LinuxSerial_send_byte(struct LinuxSerial_Instance *_instance, int16_t device, uint8_t byte) {
{
int n;
		unsigned char data[1];
		data[0] = byte;
        
		n = write(device, data, 1);
		if (n < 0) {
			perror("Error writing to Serial device");
			return -1;
		}
		return 0;
}
}

// Fork a thread to execute the function f_LinuxSerial_start_receiver_process

// Struct for the parameters of the function  f_LinuxSerial_start_receiver_process
struct f_LinuxSerial_start_receiver_process_struct {
  struct LinuxSerial_Instance *_instance;
   int16_t device;

  pthread_mutex_t *lock;
  pthread_cond_t *cv;
};

// Definition of function start_receiver_process (executed in a separate thread)
void f_LinuxSerial_start_receiver_process_run(struct LinuxSerial_Instance *_instance, int16_t device)
{
  {
char buffer[INPUT_BUFFER_SIZE]; // Data read from the ESUSMS device

		int n; // used to store the results of select and read
		int i; // loop index
	
		while (1) {
	
			struct timeval timeout; // timeout waiting for incoming data
			timeout.tv_sec = TIMEOUT; 	// 10 second timeout
			timeout.tv_usec = 0;
	
			fd_set rdfs;		// The file descriptor to wait on
			FD_ZERO( &rdfs );
			FD_SET( device, &rdfs ); // set to the esusms fd
	
			n = select(device+1, &rdfs, NULL, NULL, &timeout); // Wait for timeout for something to be available to read
	
			if (n < 0) {
				perror("Error waiting for incoming data from Serial device");
				break;
			}
			else if (n == 0) { // timeout
				printf("Timeout waiting for incoming data from Serial device\n");
				break;
			}
			else { // there is something to read
	
				n = read(device, &buffer, INPUT_BUFFER_SIZE * sizeof(char));
	
				if (n<0) {
					perror("Error reading from Serial device");
					break;
				}
				else if (n==0) {
					printf("Nothing to read from Serial device\n"); // Should never happen unless there are too many transmission errors with wrong CRCs
					break;
				}
				else { // There are n incoming bytes in buffer
	
					char c;
					int size;
	
					for (i = 0; i<n; i++) {
						
LinuxSerial_send_serial_serial_rx(_instance, buffer[i]);

					}
				}
			}
		}
LinuxSerial_send_serial_serial_closed(_instance);
}

}


void f_LinuxSerial_start_receiver_process_proc(void * p)
{
  // Get parameters from the main thread
  struct f_LinuxSerial_start_receiver_process_struct params = *((struct f_LinuxSerial_start_receiver_process_struct *) p);
  
  // Unblock the main thread
  pthread_mutex_lock(params.lock);
  pthread_cond_signal(params.cv);
  pthread_mutex_unlock(params.lock);
  
  // Run the function
  //f_LinuxSerial_start_receiver_process_run(params._instance, params.esums_device);
  f_LinuxSerial_start_receiver_process_run(params._instance, params.device);
}

// Operation called by the runtime and forking a new thread
void f_LinuxSerial_start_receiver_process(struct LinuxSerial_Instance *_instance, int16_t device)
{
  // Store parameters
  struct f_LinuxSerial_start_receiver_process_struct params;
  pthread_mutex_t lock;
  pthread_cond_t cv;
  params.lock = &lock;
  params.cv = &cv;
  params._instance = _instance;
  params.device = device;

  pthread_mutex_init(params.lock, NULL);
  pthread_cond_init(params.cv, NULL);
  //Start the new thread
  pthread_mutex_lock(params.lock);
  pthread_t thread; 
  pthread_create( &thread, NULL, f_LinuxSerial_start_receiver_process_proc, (void*) &params);
  // Wait until it has started and read its parameters
  pthread_cond_wait(params.cv, params.lock);
  // Realease mutex
  pthread_mutex_unlock(params.lock);
}

// On Entry Actions:
void LinuxSerial_LinuxSerialImpl_OnEntry(int state, struct LinuxSerial_Instance *_instance) {
switch(state) {
case LINUXSERIAL_LINUXSERIALIMPL_STATE:
_instance->LinuxSerial_LinuxSerialImpl_State = LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE;
LinuxSerial_LinuxSerialImpl_OnEntry(_instance->LinuxSerial_LinuxSerialImpl_State, _instance);
break;
case LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE:
break;
default: break;
}
}

// On Exit Actions:
void LinuxSerial_LinuxSerialImpl_OnExit(int state, struct LinuxSerial_Instance *_instance) {
switch(state) {
case LINUXSERIAL_LINUXSERIALIMPL_STATE:
LinuxSerial_LinuxSerialImpl_OnExit(_instance->LinuxSerial_LinuxSerialImpl_State, _instance);
break;
case LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void LinuxSerial_handle_serial_serial_open(struct LinuxSerial_Instance *_instance, char * device, int baudrate) {
uint8_t LinuxSerial_LinuxSerialImpl_State_event_consumed = 0;
if (_instance->LinuxSerial_LinuxSerialImpl_State == LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE) {
if (LinuxSerial_LinuxSerialImpl_State_event_consumed == 0 && 1) {
{
_instance->LinuxSerial_LinuxSerialImpl_serial_device__var = f_LinuxSerial_open_serial(_instance, device, baudrate);
if(_instance->LinuxSerial_LinuxSerialImpl_serial_device__var >  -1) {
f_LinuxSerial_start_receiver_process(_instance, _instance->LinuxSerial_LinuxSerialImpl_serial_device__var);
LinuxSerial_send_serial_serial_opened(_instance);
}
}
LinuxSerial_LinuxSerialImpl_State_event_consumed = 1;
}
}
}
void LinuxSerial_handle_serial_serial_tx(struct LinuxSerial_Instance *_instance, uint8_t b) {
uint8_t LinuxSerial_LinuxSerialImpl_State_event_consumed = 0;
if (_instance->LinuxSerial_LinuxSerialImpl_State == LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE) {
if (LinuxSerial_LinuxSerialImpl_State_event_consumed == 0 && 1) {
{
// PRINT: "writing"
f_LinuxSerial_send_byte(_instance, _instance->LinuxSerial_LinuxSerialImpl_serial_device__var, b);
}
LinuxSerial_LinuxSerialImpl_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*LinuxSerial_send_serial_serial_rx_listener)(struct LinuxSerial_Instance*, uint8_t)= 0x0;
void register_LinuxSerial_send_serial_serial_rx_listener(void (*_listener)(struct LinuxSerial_Instance*, uint8_t)){
LinuxSerial_send_serial_serial_rx_listener = _listener;
}
void LinuxSerial_send_serial_serial_rx(struct LinuxSerial_Instance *_instance, uint8_t b){
if (LinuxSerial_send_serial_serial_rx_listener != 0x0) LinuxSerial_send_serial_serial_rx_listener(_instance, b);
}
void (*LinuxSerial_send_serial_serial_closed_listener)(struct LinuxSerial_Instance*)= 0x0;
void register_LinuxSerial_send_serial_serial_closed_listener(void (*_listener)(struct LinuxSerial_Instance*)){
LinuxSerial_send_serial_serial_closed_listener = _listener;
}
void LinuxSerial_send_serial_serial_closed(struct LinuxSerial_Instance *_instance){
if (LinuxSerial_send_serial_serial_closed_listener != 0x0) LinuxSerial_send_serial_serial_closed_listener(_instance);
}
void (*LinuxSerial_send_serial_serial_opened_listener)(struct LinuxSerial_Instance*)= 0x0;
void register_LinuxSerial_send_serial_serial_opened_listener(void (*_listener)(struct LinuxSerial_Instance*)){
LinuxSerial_send_serial_serial_opened_listener = _listener;
}
void LinuxSerial_send_serial_serial_opened(struct LinuxSerial_Instance *_instance){
if (LinuxSerial_send_serial_serial_opened_listener != 0x0) LinuxSerial_send_serial_serial_opened_listener(_instance);
}

/*****************************************************************************
 * Headers for type : Test
 *****************************************************************************/

// Definition of the instance stuct:
struct Test_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int Test_testChart_State;
// Variables for the properties of the instance
uint8_t Test_On__var;
uint16_t Test_time__var;
uint8_t Test_timerID__var;
uint8_t Test_Led__var;
};

// Declaration of prototypes outgoing messages:
void Test_testChart_OnEntry(int state, struct Test_Instance *_instance);
void Test_handle_bridge_CPUBridgeReady(struct Test_Instance *_instance);
void Test_handle_bridge_timeout(struct Test_Instance *_instance, uint8_t id);
// Declaration of callbacks for incomming messages:
void register_Test_send_bridge_setDigitalHigh_listener(void (*_listener)(struct Test_Instance*, uint8_t));
void register_Test_send_bridge_setDigitalLow_listener(void (*_listener)(struct Test_Instance*, uint8_t));
void register_Test_send_bridge_setOutput_listener(void (*_listener)(struct Test_Instance*, uint8_t));
void register_Test_send_bridge_setInput_listener(void (*_listener)(struct Test_Instance*, uint8_t));
void register_Test_send_bridge_readDigital_listener(void (*_listener)(struct Test_Instance*, uint8_t));
void register_Test_send_bridge_readAnalog_listener(void (*_listener)(struct Test_Instance*, uint8_t));
void register_Test_send_bridge_timer_start_listener(void (*_listener)(struct Test_Instance*, uint8_t, int16_t));
void register_Test_send_bridge_timer_cancel_listener(void (*_listener)(struct Test_Instance*, uint8_t));

// Definition of the states:
#define TEST_TESTCHART_STATE 0
#define TEST_TESTCHART_INIT_STATE 1
#define TEST_TESTCHART_BLINK_STATE 2

/*****************************************************************************
 * Implementation for type : Test
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void Test_testChart_OnExit(int state, struct Test_Instance *_instance);
void Test_send_bridge_setDigitalHigh(struct Test_Instance *_instance, uint8_t pin);
void Test_send_bridge_setDigitalLow(struct Test_Instance *_instance, uint8_t pin);
void Test_send_bridge_setOutput(struct Test_Instance *_instance, uint8_t pin);
void Test_send_bridge_setInput(struct Test_Instance *_instance, uint8_t pin);
void Test_send_bridge_readDigital(struct Test_Instance *_instance, uint8_t pin);
void Test_send_bridge_readAnalog(struct Test_Instance *_instance, uint8_t pin);
void Test_send_bridge_timer_start(struct Test_Instance *_instance, uint8_t id, int16_t time);
void Test_send_bridge_timer_cancel(struct Test_Instance *_instance, uint8_t id);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void Test_testChart_OnEntry(int state, struct Test_Instance *_instance) {
switch(state) {
case TEST_TESTCHART_STATE:
_instance->Test_testChart_State = TEST_TESTCHART_INIT_STATE;
Test_testChart_OnEntry(_instance->Test_testChart_State, _instance);
break;
case TEST_TESTCHART_INIT_STATE:
{
// PRINT: "Test Init"
}
break;
case TEST_TESTCHART_BLINK_STATE:
{
// PRINT: "Blink"
Test_send_bridge_timer_start(_instance, _instance->Test_timerID__var, _instance->Test_time__var);
if(_instance->Test_On__var) {
Test_send_bridge_setDigitalLow(_instance, _instance->Test_Led__var);
}
if( !(_instance->Test_On__var)) {
Test_send_bridge_setDigitalHigh(_instance, _instance->Test_Led__var);
}
_instance->Test_On__var =  !(_instance->Test_On__var);
}
break;
default: break;
}
}

// On Exit Actions:
void Test_testChart_OnExit(int state, struct Test_Instance *_instance) {
switch(state) {
case TEST_TESTCHART_STATE:
Test_testChart_OnExit(_instance->Test_testChart_State, _instance);
break;
case TEST_TESTCHART_INIT_STATE:
break;
case TEST_TESTCHART_BLINK_STATE:
break;
default: break;
}
}

// Event Handlers for incoming messages:
void Test_handle_bridge_CPUBridgeReady(struct Test_Instance *_instance) {
uint8_t Test_testChart_State_event_consumed = 0;
if (_instance->Test_testChart_State == TEST_TESTCHART_INIT_STATE) {
if (Test_testChart_State_event_consumed == 0 && 1) {
Test_testChart_OnExit(TEST_TESTCHART_INIT_STATE, _instance);
_instance->Test_testChart_State = TEST_TESTCHART_BLINK_STATE;
{
Test_send_bridge_setOutput(_instance, _instance->Test_Led__var);
}
Test_testChart_OnEntry(TEST_TESTCHART_BLINK_STATE, _instance);
Test_testChart_State_event_consumed = 1;
}
}
}
void Test_handle_bridge_timeout(struct Test_Instance *_instance, uint8_t id) {
uint8_t Test_testChart_State_event_consumed = 0;
if (_instance->Test_testChart_State == TEST_TESTCHART_BLINK_STATE) {
if (Test_testChart_State_event_consumed == 0 && 1) {
Test_testChart_OnExit(TEST_TESTCHART_BLINK_STATE, _instance);
_instance->Test_testChart_State = TEST_TESTCHART_BLINK_STATE;
Test_testChart_OnEntry(TEST_TESTCHART_BLINK_STATE, _instance);
Test_testChart_State_event_consumed = 1;
}
}
}

// Observers for outgoing messages:
void (*Test_send_bridge_setDigitalHigh_listener)(struct Test_Instance*, uint8_t)= 0x0;
void register_Test_send_bridge_setDigitalHigh_listener(void (*_listener)(struct Test_Instance*, uint8_t)){
Test_send_bridge_setDigitalHigh_listener = _listener;
}
void Test_send_bridge_setDigitalHigh(struct Test_Instance *_instance, uint8_t pin){
if (Test_send_bridge_setDigitalHigh_listener != 0x0) Test_send_bridge_setDigitalHigh_listener(_instance, pin);
}
void (*Test_send_bridge_setDigitalLow_listener)(struct Test_Instance*, uint8_t)= 0x0;
void register_Test_send_bridge_setDigitalLow_listener(void (*_listener)(struct Test_Instance*, uint8_t)){
Test_send_bridge_setDigitalLow_listener = _listener;
}
void Test_send_bridge_setDigitalLow(struct Test_Instance *_instance, uint8_t pin){
if (Test_send_bridge_setDigitalLow_listener != 0x0) Test_send_bridge_setDigitalLow_listener(_instance, pin);
}
void (*Test_send_bridge_setOutput_listener)(struct Test_Instance*, uint8_t)= 0x0;
void register_Test_send_bridge_setOutput_listener(void (*_listener)(struct Test_Instance*, uint8_t)){
Test_send_bridge_setOutput_listener = _listener;
}
void Test_send_bridge_setOutput(struct Test_Instance *_instance, uint8_t pin){
if (Test_send_bridge_setOutput_listener != 0x0) Test_send_bridge_setOutput_listener(_instance, pin);
}
void (*Test_send_bridge_setInput_listener)(struct Test_Instance*, uint8_t)= 0x0;
void register_Test_send_bridge_setInput_listener(void (*_listener)(struct Test_Instance*, uint8_t)){
Test_send_bridge_setInput_listener = _listener;
}
void Test_send_bridge_setInput(struct Test_Instance *_instance, uint8_t pin){
if (Test_send_bridge_setInput_listener != 0x0) Test_send_bridge_setInput_listener(_instance, pin);
}
void (*Test_send_bridge_readDigital_listener)(struct Test_Instance*, uint8_t)= 0x0;
void register_Test_send_bridge_readDigital_listener(void (*_listener)(struct Test_Instance*, uint8_t)){
Test_send_bridge_readDigital_listener = _listener;
}
void Test_send_bridge_readDigital(struct Test_Instance *_instance, uint8_t pin){
if (Test_send_bridge_readDigital_listener != 0x0) Test_send_bridge_readDigital_listener(_instance, pin);
}
void (*Test_send_bridge_readAnalog_listener)(struct Test_Instance*, uint8_t)= 0x0;
void register_Test_send_bridge_readAnalog_listener(void (*_listener)(struct Test_Instance*, uint8_t)){
Test_send_bridge_readAnalog_listener = _listener;
}
void Test_send_bridge_readAnalog(struct Test_Instance *_instance, uint8_t pin){
if (Test_send_bridge_readAnalog_listener != 0x0) Test_send_bridge_readAnalog_listener(_instance, pin);
}
void (*Test_send_bridge_timer_start_listener)(struct Test_Instance*, uint8_t, int16_t)= 0x0;
void register_Test_send_bridge_timer_start_listener(void (*_listener)(struct Test_Instance*, uint8_t, int16_t)){
Test_send_bridge_timer_start_listener = _listener;
}
void Test_send_bridge_timer_start(struct Test_Instance *_instance, uint8_t id, int16_t time){
if (Test_send_bridge_timer_start_listener != 0x0) Test_send_bridge_timer_start_listener(_instance, id, time);
}
void (*Test_send_bridge_timer_cancel_listener)(struct Test_Instance*, uint8_t)= 0x0;
void register_Test_send_bridge_timer_cancel_listener(void (*_listener)(struct Test_Instance*, uint8_t)){
Test_send_bridge_timer_cancel_listener = _listener;
}
void Test_send_bridge_timer_cancel(struct Test_Instance *_instance, uint8_t id){
if (Test_send_bridge_timer_cancel_listener != 0x0) Test_send_bridge_timer_cancel_listener(_instance, id);
}


/*****************************************************************************
 * Definitions for configuration : TestCfg
 *****************************************************************************/

#define MAX_INSTANCES 32
#define FIFO_SIZE 256

/*********************************
 * Instance IDs and lookup
 *********************************/

void * instances[MAX_INSTANCES];
uint16_t instances_count = 0;

void * instance_by_id(uint16_t id) {
  return instances[id];
}

uint16_t add_instance(void * instance_struct) {
  instances[instances_count] = instance_struct;
  return instances_count++;
}

/******************************************
 * Simple byte FIFO implementation
 ******************************************/

byte fifo[FIFO_SIZE];
int fifo_head = 0;
int fifo_tail = 0;

// Returns the number of byte currently in the fifo
int fifo_byte_length() {
  if (fifo_tail >= fifo_head)
    return fifo_tail - fifo_head;
  return fifo_tail + FIFO_SIZE - fifo_head;
}

// Returns the number of bytes currently available in the fifo
int fifo_byte_available() {
  return FIFO_SIZE - 1 - fifo_byte_length();
}

// Returns true if the fifo is empty
int fifo_empty() {
  return fifo_head == fifo_tail;
}

// Return true if the fifo is full
int fifo_full() {
  return fifo_head == ((fifo_tail + 1) % FIFO_SIZE);
}

// Enqueue 1 byte in the fifo if there is space
// returns 1 for sucess and 0 if the fifo was full
int fifo_enqueue(byte b) {
  int new_tail = (fifo_tail + 1) % FIFO_SIZE;
  if (new_tail == fifo_head) return 0; // the fifo is full
  fifo[fifo_tail] = b;
  fifo_tail = new_tail;
  return 1;
}

// Enqueue 1 byte in the fifo without checking for available space
// The caller should have checked that there is enough space
int _fifo_enqueue(byte b) {
  fifo[fifo_tail] = b;
  fifo_tail = (fifo_tail + 1) % FIFO_SIZE;
}

// Dequeue 1 byte in the fifo.
// The caller should check that the fifo is not empty
byte fifo_dequeue() {
  if (!fifo_empty()) {
    byte result = fifo[fifo_head];
    fifo_head = (fifo_head + 1) % FIFO_SIZE;
    return result;
  }
  return 0;
}

/*
void _fifo_enqueue_ptr(void * ptr) {
  int i;
  ptr_union_t proxy;
  proxy.pointer = ptr;
  for (i = 0; i<PTR_MAX_SIZE; i++) _fifo_enqueue(proxy.buffer[i]);
}

void * _fifo_dequeue_ptr() {
  int i;
  ptr_union_t proxy;
  for (i = 0; i<PTR_MAX_SIZE; i++) proxy.buffer[i] = _fifo_dequeue();
  return proxy.pointer;
}
*/
//Declaration of instance variables
struct LinuxSerial_Instance TestCfg_sp_var;
struct Test_Instance TestCfg_t_var;
struct Bridge_Instance TestCfg_bridge_var;

// Enqueue of messages Bridge::Serial1::readDigitalResponse
void enqueue_Bridge_send_Serial1_readDigitalResponse(struct Bridge_Instance *_instance, uint8_t pin, uint8_t DigitalState){
if ( fifo_byte_available() > 6 ) {

_fifo_enqueue( (1 >> 8) & 0xFF );
_fifo_enqueue( 1 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);

// parameter DigitalState
_fifo_enqueue(DigitalState & 0xFF);
}
}
// Enqueue of messages Bridge::Serial1::readAnalogResponse
void enqueue_Bridge_send_Serial1_readAnalogResponse(struct Bridge_Instance *_instance, uint8_t pin, int res){
if ( fifo_byte_available() > 7 ) {

_fifo_enqueue( (2 >> 8) & 0xFF );
_fifo_enqueue( 2 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);

// parameter res
_fifo_enqueue((res>>8) & 0xFF);
_fifo_enqueue(res & 0xFF);
}
}
// Enqueue of messages Bridge::Serial1::CPUBridgeReady
void enqueue_Bridge_send_Serial1_CPUBridgeReady(struct Bridge_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (3 >> 8) & 0xFF );
_fifo_enqueue( 3 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages Bridge::Serial1::timeout
void enqueue_Bridge_send_Serial1_timeout(struct Bridge_Instance *_instance, uint8_t id){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (4 >> 8) & 0xFF );
_fifo_enqueue( 4 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter id
_fifo_enqueue(id & 0xFF);
}
}
// Enqueue of messages Test::bridge::setDigitalHigh
void enqueue_Test_send_bridge_setDigitalHigh(struct Test_Instance *_instance, uint8_t pin){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (5 >> 8) & 0xFF );
_fifo_enqueue( 5 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);
}
}
// Enqueue of messages Test::bridge::readAnalog
void enqueue_Test_send_bridge_readAnalog(struct Test_Instance *_instance, uint8_t pin){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (6 >> 8) & 0xFF );
_fifo_enqueue( 6 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);
}
}
// Enqueue of messages Test::bridge::readDigital
void enqueue_Test_send_bridge_readDigital(struct Test_Instance *_instance, uint8_t pin){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (7 >> 8) & 0xFF );
_fifo_enqueue( 7 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);
}
}
// Enqueue of messages Test::bridge::setOutput
void enqueue_Test_send_bridge_setOutput(struct Test_Instance *_instance, uint8_t pin){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (8 >> 8) & 0xFF );
_fifo_enqueue( 8 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);
}
}
// Enqueue of messages Test::bridge::setInput
void enqueue_Test_send_bridge_setInput(struct Test_Instance *_instance, uint8_t pin){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (9 >> 8) & 0xFF );
_fifo_enqueue( 9 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);
}
}
// Enqueue of messages Test::bridge::timer_start
void enqueue_Test_send_bridge_timer_start(struct Test_Instance *_instance, uint8_t id, int16_t time){
if ( fifo_byte_available() > 7 ) {

_fifo_enqueue( (10 >> 8) & 0xFF );
_fifo_enqueue( 10 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter id
_fifo_enqueue(id & 0xFF);

// parameter time
_fifo_enqueue((time>>8) & 0xFF);
_fifo_enqueue(time & 0xFF);
}
}
// Enqueue of messages Test::bridge::timer_cancel
void enqueue_Test_send_bridge_timer_cancel(struct Test_Instance *_instance, uint8_t id){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (11 >> 8) & 0xFF );
_fifo_enqueue( 11 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter id
_fifo_enqueue(id & 0xFF);
}
}
// Enqueue of messages Test::bridge::setDigitalLow
void enqueue_Test_send_bridge_setDigitalLow(struct Test_Instance *_instance, uint8_t pin){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (12 >> 8) & 0xFF );
_fifo_enqueue( 12 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);
}
}

// Dispatch for messages Test::bridge::setDigitalHigh
void dispatch_Test_send_bridge_setDigitalHigh(struct Test_Instance *_instance, uint8_t pin){
if (_instance == &TestCfg_t_var) {
Bridge_handle_Serial1_setDigitalHigh(&TestCfg_bridge_var, pin);
}
}
// Dispatch for messages Test::bridge::readAnalog
void dispatch_Test_send_bridge_readAnalog(struct Test_Instance *_instance, uint8_t pin){
if (_instance == &TestCfg_t_var) {
Bridge_handle_Serial1_readAnalog(&TestCfg_bridge_var, pin);
}
}
// Dispatch for messages Test::bridge::readDigital
void dispatch_Test_send_bridge_readDigital(struct Test_Instance *_instance, uint8_t pin){
if (_instance == &TestCfg_t_var) {
Bridge_handle_Serial1_readDigital(&TestCfg_bridge_var, pin);
}
}
// Dispatch for messages Test::bridge::setOutput
void dispatch_Test_send_bridge_setOutput(struct Test_Instance *_instance, uint8_t pin){
if (_instance == &TestCfg_t_var) {
Bridge_handle_Serial1_setOutput(&TestCfg_bridge_var, pin);
}
}
// Dispatch for messages Test::bridge::setInput
void dispatch_Test_send_bridge_setInput(struct Test_Instance *_instance, uint8_t pin){
if (_instance == &TestCfg_t_var) {
Bridge_handle_Serial1_setInput(&TestCfg_bridge_var, pin);
}
}
// Dispatch for messages Test::bridge::timer_start
void dispatch_Test_send_bridge_timer_start(struct Test_Instance *_instance, uint8_t id, int16_t time){
if (_instance == &TestCfg_t_var) {
Bridge_handle_Serial1_timer_start(&TestCfg_bridge_var, id, time);
}
}
// Dispatch for messages Test::bridge::timer_cancel
void dispatch_Test_send_bridge_timer_cancel(struct Test_Instance *_instance, uint8_t id){
if (_instance == &TestCfg_t_var) {
Bridge_handle_Serial1_timer_cancel(&TestCfg_bridge_var, id);
}
}
// Dispatch for messages Test::bridge::setDigitalLow
void dispatch_Test_send_bridge_setDigitalLow(struct Test_Instance *_instance, uint8_t pin){
if (_instance == &TestCfg_t_var) {
Bridge_handle_Serial1_setDigitalLow(&TestCfg_bridge_var, pin);
}
}
// Dispatch for messages Bridge::Serial1::readDigitalResponse
void dispatch_Bridge_send_Serial1_readDigitalResponse(struct Bridge_Instance *_instance, uint8_t pin, uint8_t DigitalState){
if (_instance == &TestCfg_bridge_var) {
}
}
// Dispatch for messages Bridge::Serial1::readAnalogResponse
void dispatch_Bridge_send_Serial1_readAnalogResponse(struct Bridge_Instance *_instance, uint8_t pin, int res){
if (_instance == &TestCfg_bridge_var) {
}
}
// Dispatch for messages Bridge::Serial1::CPUBridgeReady
void dispatch_Bridge_send_Serial1_CPUBridgeReady(struct Bridge_Instance *_instance){
if (_instance == &TestCfg_bridge_var) {
Test_handle_bridge_CPUBridgeReady(&TestCfg_t_var);
}
}
// Dispatch for messages Bridge::Serial1::timeout
void dispatch_Bridge_send_Serial1_timeout(struct Bridge_Instance *_instance, uint8_t id){
if (_instance == &TestCfg_bridge_var) {
Test_handle_bridge_timeout(&TestCfg_t_var, id);
}
}
// Dispatch for messages Bridge::serial::serial_close
void dispatch_Bridge_send_serial_serial_close(struct Bridge_Instance *_instance){
if (_instance == &TestCfg_bridge_var) {
}
}
// Dispatch for messages Bridge::serial::serial_open
void dispatch_Bridge_send_serial_serial_open(struct Bridge_Instance *_instance, char * device, int baudrate){
if (_instance == &TestCfg_bridge_var) {
LinuxSerial_handle_serial_serial_open(&TestCfg_sp_var, device, baudrate);
}
}
// Dispatch for messages Bridge::serial::serial_tx
void dispatch_Bridge_send_serial_serial_tx(struct Bridge_Instance *_instance, uint8_t b){
if (_instance == &TestCfg_bridge_var) {
LinuxSerial_handle_serial_serial_tx(&TestCfg_sp_var, b);
}
}
// Dispatch for messages LinuxSerial::serial::serial_closed
void dispatch_LinuxSerial_send_serial_serial_closed(struct LinuxSerial_Instance *_instance){
if (_instance == &TestCfg_sp_var) {
}
}
// Dispatch for messages LinuxSerial::serial::serial_opened
void dispatch_LinuxSerial_send_serial_serial_opened(struct LinuxSerial_Instance *_instance){
if (_instance == &TestCfg_sp_var) {
Bridge_handle_serial_serial_opened(&TestCfg_bridge_var);
}
}
// Dispatch for messages LinuxSerial::serial::serial_rx
void dispatch_LinuxSerial_send_serial_serial_rx(struct LinuxSerial_Instance *_instance, uint8_t b){
if (_instance == &TestCfg_sp_var) {
Bridge_handle_serial_serial_rx(&TestCfg_bridge_var, b);
}
}

void processMessageQueue() {
if (fifo_empty()) return; // return if there is nothing to do

byte mbuf[5];
uint8_t mbufi = 0;

// Read the code of the next port/message in the queue
uint16_t code = fifo_dequeue() << 8;

code += fifo_dequeue();

// Switch to call the appropriate handler
switch(code) {
case 5:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_Test_send_bridge_setDigitalHigh((struct Test_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ );
break;
case 6:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_Test_send_bridge_readAnalog((struct Test_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ );
break;
case 7:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_Test_send_bridge_readDigital((struct Test_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ );
break;
case 8:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_Test_send_bridge_setOutput((struct Test_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ );
break;
case 9:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_Test_send_bridge_setInput((struct Test_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ );
break;
case 10:
while (mbufi < 5) mbuf[mbufi++] = fifo_dequeue();
dispatch_Test_send_bridge_timer_start((struct Test_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* id */ ,
(mbuf[3]<<8) + mbuf[4] /* time */ );
break;
case 11:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_Test_send_bridge_timer_cancel((struct Test_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* id */ );
break;
case 12:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_Test_send_bridge_setDigitalLow((struct Test_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ );
break;
case 1:
while (mbufi < 4) mbuf[mbufi++] = fifo_dequeue();
dispatch_Bridge_send_Serial1_readDigitalResponse((struct Bridge_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ ,
mbuf[3] /* DigitalState */ );
break;
case 2:
while (mbufi < 5) mbuf[mbufi++] = fifo_dequeue();
dispatch_Bridge_send_Serial1_readAnalogResponse((struct Bridge_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ ,
(mbuf[3]<<8) + mbuf[4] /* res */ );
break;
case 3:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_Bridge_send_Serial1_CPUBridgeReady((struct Bridge_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 4:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_Bridge_send_Serial1_timeout((struct Bridge_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* id */ );
break;
}
}

void initialize_configuration_TestCfg() {
// Initialize connectors
register_Bridge_send_Serial1_readDigitalResponse_listener(enqueue_Bridge_send_Serial1_readDigitalResponse);
register_Bridge_send_Serial1_readAnalogResponse_listener(enqueue_Bridge_send_Serial1_readAnalogResponse);
register_Bridge_send_Serial1_timeout_listener(enqueue_Bridge_send_Serial1_timeout);
register_Bridge_send_Serial1_CPUBridgeReady_listener(enqueue_Bridge_send_Serial1_CPUBridgeReady);
register_Bridge_send_serial_serial_open_listener(dispatch_Bridge_send_serial_serial_open);
register_Bridge_send_serial_serial_close_listener(dispatch_Bridge_send_serial_serial_close);
register_Bridge_send_serial_serial_tx_listener(dispatch_Bridge_send_serial_serial_tx);
register_LinuxSerial_send_serial_serial_rx_listener(dispatch_LinuxSerial_send_serial_serial_rx);
register_LinuxSerial_send_serial_serial_closed_listener(dispatch_LinuxSerial_send_serial_serial_closed);
register_LinuxSerial_send_serial_serial_opened_listener(dispatch_LinuxSerial_send_serial_serial_opened);
register_Test_send_bridge_setDigitalHigh_listener(enqueue_Test_send_bridge_setDigitalHigh);
register_Test_send_bridge_setDigitalLow_listener(enqueue_Test_send_bridge_setDigitalLow);
register_Test_send_bridge_setOutput_listener(enqueue_Test_send_bridge_setOutput);
register_Test_send_bridge_setInput_listener(enqueue_Test_send_bridge_setInput);
register_Test_send_bridge_readDigital_listener(enqueue_Test_send_bridge_readDigital);
register_Test_send_bridge_readAnalog_listener(enqueue_Test_send_bridge_readAnalog);
register_Test_send_bridge_timer_start_listener(enqueue_Test_send_bridge_timer_start);
register_Test_send_bridge_timer_cancel_listener(enqueue_Test_send_bridge_timer_cancel);

// Init the ID, state variables and properties for instance TestCfg_bridge
TestCfg_bridge_var.id = add_instance( (void*) &TestCfg_bridge_var);
TestCfg_bridge_var.Bridge_BridgeChart_State = BRIDGE_BRIDGECHART_INIT_STATE;
TestCfg_bridge_var.Bridge_BridgeChart_Active_State = BRIDGE_BRIDGECHART_ACTIVE_IDLE_STATE;
TestCfg_bridge_var.Bridge_START_BYTE__var = 18;
TestCfg_bridge_var.Bridge_STOP_BYTE__var = 19;
TestCfg_bridge_var.Bridge_ESCAPE_BYTE__var = 125;
TestCfg_bridge_var.Bridge_MsgSize__var = 0;

// Init the ID, state variables and properties for instance TestCfg_sp
TestCfg_sp_var.id = add_instance( (void*) &TestCfg_sp_var);
TestCfg_sp_var.LinuxSerial_LinuxSerialImpl_State = LINUXSERIAL_LINUXSERIALIMPL_RUNNING_STATE;

// Init the ID, state variables and properties for instance TestCfg_t
TestCfg_t_var.id = add_instance( (void*) &TestCfg_t_var);
TestCfg_t_var.Test_testChart_State = TEST_TESTCHART_INIT_STATE;
TestCfg_t_var.Test_On__var = 0;
TestCfg_t_var.Test_time__var = 500;
TestCfg_t_var.Test_timerID__var = 0;
TestCfg_t_var.Test_Led__var = 13;

LinuxSerial_LinuxSerialImpl_OnEntry(LINUXSERIAL_LINUXSERIALIMPL_STATE, &TestCfg_sp_var);
Bridge_BridgeChart_OnEntry(BRIDGE_BRIDGECHART_STATE, &TestCfg_bridge_var);
Test_testChart_OnEntry(TEST_TESTCHART_STATE, &TestCfg_t_var);
}

/*****************************************************************************
 * Main for configuration : TestCfg
 *****************************************************************************/

void setup() {
initialize_configuration_TestCfg();

}

void loop() {
Bridge_handle_empty_event(&TestCfg_bridge_var);

processMessageQueue();
}